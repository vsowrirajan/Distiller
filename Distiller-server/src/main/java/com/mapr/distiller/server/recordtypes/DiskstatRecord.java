package com.mapr.distiller.server.recordtypes;

import java.io.File;
import java.io.RandomAccessFile;
import java.math.BigInteger;
import com.mapr.distiller.server.queues.RecordQueue;

public class DiskstatRecord extends Record {
	/**
	 * DERIVED VALUES
	 */


	/**
	 * RAW VALUES
	 */
	private int major_number, minor_mumber;
	private String device_name;
	private BigInteger reads_completed_successfully, reads_merged, sectors_read, time_spent_reading,
						writes_completed, writes_merged, sectors_written, time_spent_writing,
						IOs_currently_in_progress, time_spent_doing_IOs, weighted_time_spent_doing_IOs;

	/**
	 * CONSTRUCTORS
	 */
	public DiskstatRecord(long now, String[] parts) throws Exception {
		//This constructor uses "now" as the timestamp value for the record and parses values for all other raw values from the "parts" array.
		//This constructor will throw an ArrayIndexOutOfBoundsException if the "parts" array is not of the expected length
		//This constructor will throw various other types of exceptions if any of the value strings can't be parsed, e.g. NumberFormatException
		//Obviously, when the constructor throws an exception, we should consider this a failure to gather a metric sample and that should be
		//percolated up the call stack to whatever requested that a DiskstatRecord be generated
		super(now);
		this.major_number = Integer.parseInt(parts[0]);
		this.minor_mumber = Integer.parseInt(parts[1]);
		this.device_name = parts[2];
		this.reads_completed_successfully = new BigInteger(parts[3]);
		this.reads_merged = new BigInteger(parts[4]);
		this.sectors_read = new BigInteger(parts[5]);
		this.time_spent_reading = new BigInteger(parts[6]);
		this.writes_completed = new BigInteger(parts[7]);
		this.writes_merged = new BigInteger(parts[8]);
		this.sectors_written = new BigInteger(parts[9]);
		this.time_spent_writing = new BigInteger(parts[10]);
		this.IOs_currently_in_progress = new BigInteger(parts[11]);
		this.time_spent_doing_IOs = new BigInteger(parts[12]);
		this.weighted_time_spent_doing_IOs = new BigInteger(parts[13]);
	}

	/**
	 * PRODUCE RECORD METHODS
	 */
	public static boolean produceRecords(RecordQueue disk_system){
		//This method should be called to generate DiskstatRecords for all physical block devices on the system, one for each device.
		//The DiskstatRecords generated by this method are put into the disk_system record queue.
		//This method will return true if DiskstatRecords were successfully generated for all physical block devices.
		//If we fail to generate even one record for one device then this method will immediately return false.
		RandomAccessFile proc_diskstats = null;
		
		boolean returnCode = true;
		
		//Open the "/proc/diskstats" file for reading
		try {
			proc_diskstats = new RandomAccessFile("/proc/diskstats", "r");
		
			//Timestamp that will be used to indicate the time this iteration of records was generated
			long now = System.currentTimeMillis();
			
			String line = null;
			//Read the file line by line and process each line, either discarding the line or processing it into a record
			//Each line represents a block device
			while ( (line = proc_diskstats.readLine()) != null) {
				String[] parts = line.trim().split("\\s+");
				//Each line is expected to have 14 fields based on kernels we currently support
				//This is basically a lazy check against actually inspecting the procfs/kernel implementation
				//If someone were to build their own OS image it's possible we still have 14 fields but they don't mean the same things...
				//Not worrying about that for now...
				if(parts.length < 14){
					throw new Exception("Unexpected format found in /proc/diskstats, length:" + parts.length);
				}
				//Check if it's a physical device, we only want stats for physical devices
				String sys_device_path = "/sys/block/" + parts[2].replaceAll("/", "!") + "/device";
				File f = new File(sys_device_path);
				if(f.exists()){	
					//If it's a physical device, then generate a DiskstatRecord
					try{
						disk_system.put(new DiskstatRecord(now, parts));
					} catch (Exception e) {
						//The constructor may throw an exception, we catch this here and do NOT rethrow it.
						//We just set that we failed to gather a record and thus the call to this method will return false.
						//We catch this exception here so that we can continue trying to process the remaining lines in the diskstat file.
						System.err.println("Failed to generate a DiskstatRecord");
						e.printStackTrace();
						returnCode=false;
					}
				} 
			}
		} catch (Exception e) {
			System.err.println("Failed reading disksstats");
			e.printStackTrace();
			returnCode=false;
		} finally {
			try {
				proc_diskstats.close();
			} catch (Exception e) {}
		}
		return returnCode;
	}
	
	/**
	 * OTHER METHODS
	 */
	public String toString(){
		return super.toString() + " Diskstat dev:" + device_name + 
				" rcs " + reads_completed_successfully + 
				" rm " + reads_merged + 
				" sr " + sectors_read + 
				" tsr " + time_spent_reading + 
				" wc " + writes_completed + 
				" wm " + writes_merged + 
				" sw " + sectors_written +
				" tsw " + time_spent_writing + 
				" cip " + IOs_currently_in_progress + 
				" ts " + time_spent_doing_IOs + 
				" wts " + weighted_time_spent_doing_IOs;
	}
}
